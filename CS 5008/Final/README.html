<!DOCTYPE html><html><head>
      <title>README</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\mmill\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.6.8\node_modules\@shd101wyy\mume\dependencies\katex\katex.min.css">
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p,html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div{display:inline}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  300px/2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="research-paper">Research Paper</h1>

<p>Name: Michael Mills<br>
Semester: Summer 2023<br>
Topic: Combinatorial Optimization Algorithms<br>
Link The Repository:</p>
<h2 class="mume-header" id="introduction">Introduction</h2>

<p>For my final project, I decided to implement a few algorithms that are directly related to a project that I have been working on for the greater part of the year. I have been working on an application that aims to improve the way that we are able to access files. Currently, it is often the case that we will subscribe to some cloud storage service. This costs a lot of money, and the files are also stored in some unknown location. This project aims to decentralize cloud storage, so we can seamlessly access our files across all of our devices, without the need for some expensive cloud subscription plan. The cool thing about this project is that there are many strategies that can be used to determine what would be the best way to store all of these files. Should we store all of the files on just one device and leave the rest empty? Should we store the same file on multiple different devices? Should we split up files to multiple different devices, so device has one entire file? These problems are where my algorithms are able to come into play.</p>
<p>For this particular problem, I decided to look at Combinatorial Optimization Algorithms. These types of algorithms are beneficial for when we need to find an optimal solution from a finite number of combinations. In other words, there are a large number of combinations that are available, however which one would happen to be the best? There are many famous problems that are associated with this type of algorithm, such as the Traveling Salesman Problem, the Minimum Spanning Tree Problem, and the Knapsack Problem.</p>
<p>[Source: &quot;The History of Combinatorial Optimization&quot; by Alexander Schrijver, Handbook of Combinatorial Optimization, Volume 1, 1995]</p>
<p>Algorithms used to solve many various Combinatorial Optimization problems have mostly been prevalent since the early 1900s. Despite most being mostly prevalent in the 1900s, the very first attempt at solving a similar problem occured in 1736. This is when a man by the name of Leonhard Euler worked on the Seven Bridges of Konigsberg Problem. This was a problem where a city consisted of seven bridges, and Euler wanted to figure out how he could create a walk through the city that would allow the traveler to go over each of the bridges just one time.</p>
<p>The Seven Bridges of K&#xF6;nigsberg: <a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">https://en.wikipedia.org/wiki/Seven_Bridges_of_K&#xF6;nigsberg</a></p>
<p>In 1931, a man by the name of Denes Konig worked on a problem where there are a certain number of tasks, and a certain number of workers, and only one task should be assigned to one worker. In order to solve this problem Denes came up with the Konig-Egervary theorem. This theorem essentially explains that the maximum number of tasks that can be completed is equal to the minimum number of workers that are needed to complete all of the tasks.</p>
<p>The Konig-Egervary theorem: <a href="https://en.wikipedia.org/wiki/K%C5%91nig%E2%80%93Egerv%C3%A1ry_theorem">https://en.wikipedia.org/wiki/K&#x151;nig&#x2013;Egerv&#xE1;ry_theorem</a></p>
<p>In 1947, a man by the name of George Dantzig worked on solving various linear programming problems. While working as a research assistant, he was given the task to solve a certain linear programming problem. He realized that he could solve the problem through an algorithm called the Simplex Method. The simplex method is essentially starting off with a solution that works, and then iteratively coming up with a better solution until the solution becomes optimal.<br>
George Dantzig: <a href="https://en.wikipedia.org/wiki/George_Dantzig">https://en.wikipedia.org/wiki/George_Dantzig</a></p>
<p>In the 1950s and 1960s, there was a sharp increase in popularity in solving something called the traveling salesman problem. The traveling salesman problem is essentially a problem in which there is a salesman that needs to go to various locations, and there are multiple different orders in which the salesman may visit each city. For example, should he go from Boston to New York, or should he stop in Philadelphia before he goes to New York? This problem, and the subsequent algorithms that were developed for it aim to determine the best possible route for the traveling salesman.<br>
<a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">http://en.wikipedia.org/wiki/Travelling_salesman_problem</a></p>
<p>Another popular problem is the minimum spanning tree problem. This is a problem that aims to determine a tree of a graph, while maintaining the smallest total edge weight possible. This problem is particularly important in a number of different situations. For example, it can be incredibly helpful when we are thinking about and designing efficient networks. These networks don&apos;t just have to be computer networks, they can be any type of network, such as a road system when planning a new city.</p>
<p>Another popular problem in the realm of ocmputer science is the Knapsack Problem. This was mostly prevalent in the late 1950s and 1960s. The Knapsack Problem is essentially a problem in which there are a certain amount of items that consit of various weights. We are looking to find the best way to pack the knapsack. This problem works by implementing a dynamic programming approach. Additionally, this problem is mostly solved using a greedy approach, which means that each item is determined one at a time, and there is no backtracking involved.<br>
The knapsack problem: <a href="https://en.wikipedia.org/wiki/Knapsack_problem">https://en.wikipedia.org/wiki/Knapsack_problem</a></p>
<p>Now that we have learned about the history of Combinatorial Optimization Algorithms and their history, it is time to give a brief summary of what the rest of this paper will look like. To begin, I will be giving an analysis of the Algorithm, including the time complexity, space complexity, and general analysis. Next, I will be providing an empirical analysis. Next, I will discuss the application of the algorithm, including what it&apos;s used for, some real world examples of how its used, and why it can be helpful. Next, I will discuss my implementation of the algorithm, the language that I used, the libraries I used, some challenges I faced, and finally some key points.</p>
<p>Finally, I will provide an overall summary of what I found, what I learned, and how it helped me become a better computer scientist.</p>
<h2 class="mume-header" id="analysis-of-algorithmdatastructure">Analysis of Algorithm/Datastructure</h2>

<p>For these algorithms, there are multiple different parts of each algorithm that have different time complexities. In other words, each algorithm can be broken down into 3 different sections, sorting the files, sorting the devices, and the nested loop. As for sorting the files, this will normally have a time complexity of O(n log n). In this particular scenario, n will be the number of files. As for sorting the devices, this will normally have a time complexity of O(m log m). In this particular scenario, m will be the number of devices. Finally, as for the nested loop, this will normally have a time complexity of O(n * m) where again n is the number of files and m is the number of devices. Since the overall algorithm is a combination of these smaller pieeces, we are able to add all three of these time complexities together, which would be O(n log n + m log m + n * m). We are then able to simplify this to an overall time complexity of O(n * m).</p>
<p>As for the space complexity, there doesn&apos;t seem to be much wrong with the algorithm. I certainly learned a lot in this part of the project, as this was the first time that I had worked with analyzing memory in a python program. I ended up copying all of the algorithm functions to the test_space_complexity.py file, as the memory profiler doesn&apos;t review the memory of the function that is called from another file. For the most part, it seems as if the memory is mostly sound. Of course, there are variables that are assigned that will require memory. In my experience, even with incredibly high numbers for the number of files, number of devices, etc., the memory does not seem to be bad at all. In fact, I thought there was something wrong with the profiler as it was showing zeroes across the board, and I had to increase the workload in order to get it to show anything.</p>
<p>Overall I think that this is a very interesting algorithm, and probably has a lot of use cases. I think overall the algorithm works especially with large workloads and large datasets specifically because it is considered to be a greedy algorithm. In other words, the algorithm doesn&apos;t backtrack and look to change which knapsack to store the file in after it has already been placed. I think this is the sole reason why it is able to work with large numbers.</p>
<h2 class="mume-header" id="empirical-analysis">Empirical Analysis</h2>

<p>As for the time complexity, I wanted to measusure the amount of time it would take to run the algorithm, depending on the number of files and the number of devices. My theory was that this particular algorithm would take a greater amount of time to complete the greater the number of devices or files are actually in the dataset. I also made the prediction that there isn&apos;t really any difference in speed when comparing number of devices and number of files. However, both variables matter when it comes to measuring the time complexity. With these assumptions, I made the conclusion that these particular algorithms would follow a time complexity of O(n * m). I ran through the code a few times and struggled with receiving a constant time complexity. My initial thought was that this was ue to the fact that the dataset was not large enough. I then came to the conclusion that the code that I had written to measure the amount of time that had elapsed was restarting the start time after every loop. This is what caused the constant time complexity, which makes sense, since this algorithm resembles a greedy algorithm, which would have relatively the same speed for each loop, no matter how many loops there are.</p>
<p>![Time Complexity](CS 5008\Final\time_complexity.png)</p>
<p>As for the space complexity, I wanted to measure the amount of memory that was used per line of code that I had written. In order to do this, I went ahead and used the memory_profiler module, which is a popular module used to measure memory in Python. My prediction for this was that the overall program should run relatively smoothly, however whenever I assigned a variable to something, it would use memory. In my initial testing, I was really confused because it was showing there being zero memory being used. I then did some thinking and came to the conclusion that there is probably some limit to the number of decimal places that the memory profiler uses. I did some research, and came to the ocnclusion that I was correct in my assumption. My next plan of attack was to see if there was some sort of way that I can change the profiler so that it presented more than two decimal places. I quickly came to the conclusion that this was not the correct plan of attack as it would probably require me going into the profiler module and editing the module. I then came to the conclusion that instead of figuring out how to create more decimal places, I should try to figure out a way to make the numbers larger, so they would appear desipte the low number of decimal places. I then decided that increasing the size of the dataset would be the best way for me to increase the amount of memory that is being used. After modifying the dataset to make it larger, I was actually able to get numbers to show for the amount of memory used. Not only that, but the numbers were showing in the exact lines that I would expect it to be, where I am assigning variables to things.</p>
<p>![Space Complexity](CS 5008\Final\space_complexity1.png)<br>
![Space Complexity](CS 5008\Final\space_complexity2.png)<br>
![Space Complexity](CS 5008\Final\space_complexity3.png)<br>
![Space Complexity](CS 5008\Final\space_complexity4.png)<br>
![Space Complexity](CS 5008\Final\space_complexity5.png)</p>
<h2 class="mume-header" id="application">Application</h2>

<p>The algorithms I wrote are primarily used to determine the optimal allocation of files across devices. The algorithms have a number of different variables such as priority, duplication of files across multiple devices, and splitting files into pieces across devices. For example, say for instance that you have a word document that you open for work every single day. This is an important document that requires the highest level of priority. Now say for instance you also have your wedding video, which is still a really important file, but you don&apos;t think you&apos;ll be using it as frequently as that document you pull up for work every day. In terms of devices, you have a laptop, desktop, Apple Watch, iphone, two Roku devices, an iPad, and a Meta Quest 2. You live in the woods so you never have service with you iphone, but you have killer wifi speeds that your desktop is connected to 24/7. With that being said, this algorithm will determine the optimal allocation for these two files, where it may upload the word document to a large number of devices so it will increase download speeds for when you need it every morning, but it is going to store the wedding video on your iphone that isn&apos;t all that reliable in terms of service, but that&apos;s okay because you probably won&apos;t watch it for another three months.</p>
<p>There are many other examples of Combinatorial Optimization Algorithms. For example, Google Maps could use an algorithm to determine the fastest point from A to B. Another example is Amazon. Amazon could certainly use an algorithm like this when shipping products. It could be incredibly beneficial to determine what products they should ship together, and which ones would be more profitable to ship separately. Is it cheaper to ship one particular package to Philadelphia before going to New York? Or is it cheaper to go straight to New York.</p>
<h2 class="mume-header" id="implementation">Implementation</h2>

<p>For this project, I decided to implement most if not all of my work in Python. I chose Python for a number of reasons. One of which is due to the fact that I don&apos;t have to worry about memory management. This makes life much easier for when I am writing code, as I don&apos;t have to constantly think about allocating and freeing memory. I also think that Python is just an easier language to use. The syntax makes more sense and is incredibly simple. Python seems to be one of the only languages where I may not know exactly what the syntax is for a particular line of code, and when I just randomly guess what it might be, I have someone of a decent chance of being correct. Another reason why I enjoy Python is because I don&apos;t have to worry about compilers and compiling all of my code. I can just simply run the python scripts and it works. It doesn&apos;t seem like a lot, but in reality it is twice the amount of keystrokes to compile a project before you run it, and that can add up.</p>
<p>As for the libraries I used, I really did not use any libraries. I found this one repository on github that I could have used that implemented all of the algorithms automatically without having to write them all out, but I decided not to use that. I also seemed to have some very specific and custom requirements for some of the algorithms that I wrote. One library that I did use, which is not incredibly important is the tkinter library. I basically just used this as a GUI to go ahead an select which repositories or files I am interested in uploading and scanning. This just eliminates the need to manually write out the file path of what directory you are looking to scan.</p>
<p>One challenge I faced was uploading large directories. I essentially designed the program in a way where the program would go through each individual level of folders from a top down approach until all of the files have been scanned. This means that each individual file is given a CID, and information about the CID&apos;s are stored in a directory on your computer. The problem was that the process of uploading files to IPFS Seemed to slow down after 15,000 files. My immediate solution to this problem is to not give a CID to every single file on the computer, and only give CID&apos;s to directories, which seems to be possible. I am interested in going into this deeper to determine if there is anything else causing it to slow down. Another problem I had was related to actually developing the algorithms. I had many issues/bugs in many different instances. One of which was the fact that it would only pack a few files in the &quot;knapsack,&quot; and leave a large majority of the files unpacked, despite the fact that there was still space left. Another issue I had was the fact that the file sizes would go to some crazy decimal number. This caused the algorithm to just leave those files alone and not place them in a &quot;knapsack.&quot; Rounding the file size to a certain decimal fixed this.</p>
<p>Overall, I really enjoyed working on these algorithms. I am interested to see how I can improve these algorithms in the future. I feel as if the base model of the algorithm, where it just simply places files in devices almost mindlessly seems to be a little bit of a waste. However, I think once I started to incorporate different variables into the algorithm, that&apos;s when it really started to get interesting. I think theres a lot of room for improvement as well. For example, we could take into account the frequency that a file is visited or used. We could also take into account how fast the internet is for each individual device. If one particular device has terrible internet speed, you could shift all of the files or some of the files to another device that may be faster. I also think the priorty functionality is a really interesting concept as well, and could influence how many devices a particular file is on. I think the most interesting part of all, is how I would be able to implement all of these variables into one algorithm.</p>
<h2 class="mume-header" id="summary">Summary</h2>

<p>Overall, I learned a lot not only with this project but also in this class. Before this class, I had a good general understanding of algorithms and why they are important in the realm of computer science. Taking this class helped make me more aware of the concept of data structures and algorithms within applications, and how important they can be. I heard people talk about time complexities such as O(n) before this class, but now I have a solid understanding of what it means.</p>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>